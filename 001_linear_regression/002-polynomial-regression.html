<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polynomial Regression: SSE Landscape</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        :root {
            --bg-color: #fafafa;
            --card-bg: #ffffff;
            --text-color: #2c3e50;
            --accent-color: #8e44ad; /* Purple for polynomial */
            --secondary-color: #7f8c8d;
            --border-radius: 12px;
            --shadow: 0 4px 20px rgba(0,0,0,0.06);
            --font-main: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 350px 1fr;
            height: 100vh;
        }

        /* Sidebar Controls */
        .sidebar {
            background: var(--card-bg);
            padding: 25px;
            box-shadow: 4px 0 20px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            z-index: 10;
        }

        h1 {
            font-size: 1.2rem;
            font-weight: 700;
            margin: 0 0 5px 0;
            color: var(--text-color);
        }

        .subtitle {
            font-size: 0.85rem;
            color: var(--secondary-color);
            margin: 0 0 20px 0;
            line-height: 1.4;
        }

        .control-panel {
            background: #f8f9fa;
            border-radius: var(--border-radius);
            padding: 15px;
            border: 1px solid #eee;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: #555;
        }

        .value-badge {
            background: var(--accent-color);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-family: monospace;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent-color);
        }

        .stat-box {
            background: #ecf0f1;
            padding: 15px;
            border-radius: var(--border-radius);
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #e74c3c;
            font-family: monospace;
        }

        .stat-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .equation {
            font-family: monospace;
            text-align: center;
            color: var(--accent-color);
            font-weight: 600;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .buttons {
            display: flex;
            gap: 10px;
            margin-top: auto;
        }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.8rem;
            transition: opacity 0.2s;
        }

        .btn-primary { background: var(--accent-color); color: white; }
        .btn-danger { background: #e74c3c; color: white; }
        .btn-secondary { background: #95a5a6; color: white; }
        button:hover { opacity: 0.9; }

        /* Content Area */
        .content {
            padding: 20px;
            display: grid;
            grid-template-rows: 450px 600px 600px; /* 3 rows */
            gap: 20px;
            overflow-y: auto;
            background-color: #f0f2f5;
        }

        @media (max-width: 900px) {
            .main-layout { grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
            .sidebar { height: auto; max-height: 40vh; }
            .content { grid-template-rows: 400px 500px 500px; }
        }

        .viz-card {
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        
        .viz-header {
            position: absolute;
            top: 15px;
            left: 20px;
            z-index: 5;
            pointer-events: none;
            background: rgba(255,255,255,0.8);
            padding: 5px 10px;
            border-radius: 8px;
            backdrop-filter: blur(4px);
        }

        .viz-title {
            font-size: 0.95rem;
            font-weight: 700;
            color: #2c3e50;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .viz-desc {
            font-size: 0.75rem;
            color: #7f8c8d;
            margin-top: 2px;
        }

        /* 2D Plotly Container */
        #plot2d {
            width: 100%;
            height: 100%;
        }

        /* 3D Canvas Container */
        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            background: #eef2f3; /* Neutral background */
            cursor: move;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .viz-controls {
            position: absolute;
            bottom: 15px;
            right: 15px;
            display: flex;
            gap: 8px;
            z-index: 5;
        }

        .icon-btn {
            background: white;
            border: 1px solid #ddd;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #666;
            font-size: 1.2rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .icon-btn:hover { color: var(--accent-color); }
        .icon-btn.active { color: var(--accent-color); border-color: var(--accent-color); }

    </style>
</head>
<body>

<div class="main-layout">
    <!-- Sidebar -->
    <div class="sidebar">
        <div>
            <h1>Polynomial Regression</h1>
            <div class="subtitle">Interactive optimization explorer</div>
        </div>

        <div class="stat-box">
            <div class="stat-value" id="sseDisplay">0.00</div>
            <div class="stat-label">Sum of Squared Errors (SSE)</div>
            <div class="equation" id="equation">y = ax² + bx + c</div>
        </div>

        <div class="control-panel">
            <div class="control-group">
                <label>
                    Quadratic (a)
                    <span class="value-badge" id="aValue">0.00</span>
                </label>
                <input type="range" id="aSlider" min="-1" max="1" step="0.01">
            </div>

            <div class="control-group">
                <label>
                    Linear (b)
                    <span class="value-badge" id="bValue">0.00</span>
                </label>
                <input type="range" id="bSlider" min="-5" max="5" step="0.1">
            </div>

            <div class="control-group">
                <label>
                    Intercept (c)
                    <span class="value-badge" id="cValue">0.00</span>
                </label>
                <input type="range" id="cSlider" min="-10" max="20" step="0.5">
            </div>
        </div>

        <div class="buttons">
            <button class="btn-primary" id="optimizeBtn">Find Minimum</button>
            <button class="btn-secondary" id="resetBtn">Reset</button>
        </div>
        
        <div style="font-size: 0.75rem; color: #999; margin-top: 10px; line-height: 1.5;">
            <strong>Instructions:</strong><br>
            • Drag points on the 2D plot to change data.<br>
            • Drag the 3D surface to rotate view.<br>
            • <strong>Scroll</strong> to zoom in/out.<br>
            • 3D Surface shows Error for <strong>a</strong> & <strong>b</strong> (at current <strong>c</strong>).
        </div>
    </div>

    <!-- Main Content -->
    <div class="content">
        <!-- 2D Graph -->
        <div class="viz-card">
            <div class="viz-header">
                <div class="viz-title">Data & Model</div>
            </div>
            <div id="plot2d"></div>
        </div>

        <!-- 3D Graph (Normalized) -->
        <div class="viz-card">
            <div class="viz-header">
                <div class="viz-title">Normalized Loss Landscape</div>
                <div class="viz-desc">Symmetric "bowl" for 'a' and 'b' parameters</div>
            </div>
            <div class="canvas-container" id="container3d">
                <canvas id="canvas3d"></canvas>
                <div class="viz-controls">
                    <button class="icon-btn" id="rotateBtn" title="Auto Rotate">⏯</button>
                    <button class="icon-btn" id="resetViewBtn" title="Reset View">⟲</button>
                </div>
            </div>
        </div>

        <!-- 3D Graph (Raw) -->
        <div class="viz-card">
            <div class="viz-header">
                <div class="viz-title">Raw Loss Surface</div>
                <div class="viz-desc">True geometry of SSE (asymmetric)</div>
            </div>
            <div class="canvas-container" id="container3dRaw">
                <canvas id="canvas3dRaw"></canvas>
                <div class="viz-controls">
                    <button class="icon-btn" id="rotateBtnRaw" title="Auto Rotate">⏯</button>
                    <button class="icon-btn" id="resetViewBtnRaw" title="Reset View">⟲</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // ==========================================
    // DATA & STATE
    // ==========================================
    // y = 0.44x^2 + 0.21x + 0.09
    const originalData = {
        x: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        y: [0.5, 1.2, 1.8, 5.0, 7.5, 13.0, 16.5, 24.0, 29.0, 38.0, 45.0]
    };

    let data = { x: [...originalData.x], y: [...originalData.y] };
    
    // Optimization ranges for sliders & grid
    const rangeConfig = {
        a: { min: -1, max: 1, step: 0.01 },
        b: { min: -5, max: 5, step: 0.1 },
        c: { min: -10, max: 20, step: 0.5 }
    };

    let state = {
        a: 0,
        b: 0,
        c: 0,
        sse: 0,
        bestA: 0,
        bestB: 0,
        bestC: 0,
        minSSE: Infinity,
        editMode: false,
        selectedPoint: null
    };

    // 3D Visualization State (Shared between both plots)
    let canvasState = {
        rotation: { x: 0.6, y: 0.4 }, 
        zoom: 1.0, 
        autoRotate: true,
        dragging: false,
        lastMouse: { x: 0, y: 0 }
    };

    // ==========================================
    // CORE LOGIC
    // ==========================================
    function calculateSSE(a, b, c, dx, dy) {
        let error = 0;
        for (let k = 0; k < dx.length; k++) {
            const pred = a * dx[k] * dx[k] + b * dx[k] + c;
            error += Math.pow(dy[k] - pred, 2);
        }
        return error;
    }

    // Solve Normal Equations for Quadratic Regression: y = ax^2 + bx + c
    // System: X * Beta = y
    // Beta = (X^T * X)^-1 * X^T * y
    function findOptimum() {
        const N = data.x.length;
        let sumX = 0, sumX2 = 0, sumX3 = 0, sumX4 = 0;
        let sumY = 0, sumXY = 0, sumX2Y = 0;

        for (let i = 0; i < N; i++) {
            const x = data.x[i];
            const y = data.y[i];
            const x2 = x * x;
            sumX += x;
            sumX2 += x2;
            sumX3 += x2 * x;
            sumX4 += x2 * x2;
            sumY += y;
            sumXY += x * y;
            sumX2Y += x2 * y;
        }

        // Matrix A (3x3):
        // [ sumX4  sumX3  sumX2 ]
        // [ sumX3  sumX2  sumX  ]
        // [ sumX2  sumX   N     ]
        const m11 = sumX4, m12 = sumX3, m13 = sumX2;
        const m21 = sumX3, m22 = sumX2, m23 = sumX;
        const m31 = sumX2, m32 = sumX,  m33 = N;

        // Determinant of A
        const det = m11 * (m22 * m33 - m23 * m32) -
                    m12 * (m21 * m33 - m23 * m31) +
                    m13 * (m21 * m32 - m22 * m31);
        
        if (Math.abs(det) < 1e-9) return; // Singular matrix

        const invDet = 1 / det;

        // Minors for first row (to get Inverse * Vector)
        // We only need the resulting vector Beta = A^-1 * B
        // Vector B = [sumX2Y, sumXY, sumY]
        const b1 = sumX2Y, b2 = sumXY, b3 = sumY;

        // Adjugate Matrix elements (transposed cofactors)
        const adj11 =  (m22 * m33 - m23 * m32);
        const adj12 = -(m12 * m33 - m13 * m32);
        const adj13 =  (m12 * m23 - m13 * m22);
        
        const adj21 = -(m21 * m33 - m23 * m31);
        const adj22 =  (m11 * m33 - m13 * m31);
        const adj23 = -(m11 * m23 - m13 * m21);

        const adj31 =  (m21 * m32 - m22 * m31);
        const adj32 = -(m11 * m32 - m12 * m31);
        const adj33 =  (m11 * m22 - m12 * m21);

        // Beta = InvDet * Adj * B
        const A_opt = invDet * (adj11 * b1 + adj12 * b2 + adj13 * b3);
        const B_opt = invDet * (adj21 * b1 + adj22 * b2 + adj23 * b3);
        const C_opt = invDet * (adj31 * b1 + adj32 * b2 + adj33 * b3);

        state.bestA = A_opt;
        state.bestB = B_opt;
        state.bestC = C_opt;
        state.minSSE = calculateSSE(A_opt, B_opt, C_opt, data.x, data.y);
    }

    function updateState(updateSliders = false) {
        state.sse = calculateSSE(state.a, state.b, state.c, data.x, data.y);
        
        document.getElementById('sseDisplay').textContent = state.sse.toFixed(2);
        
        const signB = state.b >= 0 ? '+' : '';
        const signC = state.c >= 0 ? '+' : '';
        document.getElementById('equation').textContent = `y = ${state.a.toFixed(2)}x² ${signB}${state.b.toFixed(2)}x ${signC}${state.c.toFixed(2)}`;
        
        document.getElementById('aValue').textContent = state.a.toFixed(2);
        document.getElementById('bValue').textContent = state.b.toFixed(2);
        document.getElementById('cValue').textContent = state.c.toFixed(2);
        
        if (updateSliders) {
            document.getElementById('aSlider').value = state.a;
            document.getElementById('bSlider').value = state.b;
            document.getElementById('cSlider').value = state.c;
        }

        update2D();
        generateGrid(); // Regenerate grid because 'c' might have changed
    }

    // ==========================================
    // 2D PLOTLY
    // ==========================================
    function init2D() {
        const layout = {
            margin: { t: 20, r: 20, b: 40, l: 40 },
            xaxis: { title: 'X', range: [-1, 11], gridcolor: '#eee', fixedrange: true },
            yaxis: { title: 'Y', range: [-5, 55], gridcolor: '#eee', fixedrange: true },
            dragmode: false,
            showlegend: false,
            hovermode: 'closest',
            plot_bgcolor: 'white',
            paper_bgcolor: 'white'
        };
        
        const pointsTrace = {
            x: data.x,
            y: data.y,
            mode: 'markers',
            marker: { color: '#8e44ad', size: 15, line: { color: 'white', width: 2 } }, 
            type: 'scatter',
            hoverinfo: 'x+y'
        };

        // Create initial curve points
        const curveX = [];
        const curveY = [];
        for(let i=-1; i<=11; i+=0.2) {
            curveX.push(i);
            curveY.push(0); // Placeholder
        }

        const regressionLine = {
            x: curveX,
            y: curveY,
            mode: 'lines',
            line: { color: '#e74c3c', width: 3 },
            hoverinfo: 'skip'
        };

        // Initialize Residual Lines (placeholders)
        const residualTraces = data.x.map(() => ({
            x: [0, 0],
            y: [0, 0],
            mode: 'lines',
            line: { color: 'rgba(231, 76, 60, 0.4)', width: 1, dash: 'dash' },
            hoverinfo: 'skip',
            type: 'scatter'
        }));

        Plotly.newPlot('plot2d', [pointsTrace, regressionLine, ...residualTraces], layout, { 
            responsive: true, 
            displayModeBar: false 
        });

        // ... event listeners ...
        const plotEl = document.getElementById('plot2d');
        let hoveredPointIndex = null;
        let dragPointIndex = null;

        plotEl.on('plotly_hover', function(data) {
            if (dragPointIndex === null && data.points && data.points.length > 0 && data.points[0].curveNumber === 0) {
                hoveredPointIndex = data.points[0].pointIndex;
                plotEl.style.cursor = 'pointer';
            }
        });

        plotEl.on('plotly_unhover', function() {
            if (dragPointIndex === null) {
                hoveredPointIndex = null;
                plotEl.style.cursor = '';
            }
        });

        plotEl.addEventListener('mousedown', function(e) {
            if (hoveredPointIndex !== null) {
                dragPointIndex = hoveredPointIndex;
                plotEl.style.cursor = 'grabbing';
                document.body.style.userSelect = 'none';
                e.preventDefault(); 
            }
        });

        window.addEventListener('mousemove', function(e) {
            if (dragPointIndex === null) return;

            const rect = plotEl.getBoundingClientRect();
            const fullLayout = plotEl._fullLayout;
            const xaxis = fullLayout.xaxis;
            const yaxis = fullLayout.yaxis;

            const xPixel = e.clientX - rect.left - xaxis._offset;
            const yPixel = e.clientY - rect.top - yaxis._offset;

            let newX = xaxis.range[0] + (xPixel / xaxis._length) * (xaxis.range[1] - xaxis.range[0]);
            let newY = yaxis.range[1] - (yPixel / yaxis._length) * (yaxis.range[1] - yaxis.range[0]);

            newX = Math.max(-1, Math.min(11, newX));
            newY = Math.max(-5, Math.min(55, newY));

            data.x[dragPointIndex] = newX;
            data.y[dragPointIndex] = newY;

            // Update points trace [0]
            Plotly.restyle('plot2d', { x: [data.x], y: [data.y] }, [0]); 

            findOptimum();
            generateGrid();
            updateState();
        });

        window.addEventListener('mouseup', function() {
            if (dragPointIndex !== null) {
                dragPointIndex = null;
                plotEl.style.cursor = '';
                document.body.style.userSelect = '';
                hoveredPointIndex = null; 
            }
        });
        
        // Initial draw of residuals
        update2D();
    }

    function update2D() {
        // Update Curve Trace (Trace 1)
        const curveX = [];
        const curveY = [];
        // Sample points for smooth curve
        for(let x = -1; x <= 11; x += 0.2) {
            curveX.push(x);
            curveY.push(state.a * x * x + state.b * x + state.c);
        }

        Plotly.restyle('plot2d', {
            x: [curveX],
            y: [curveY]
        }, [1]);

        // Update Residual Lines (Traces 2 to N+2)
        const xUpdates = [];
        const yUpdates = [];
        const indices = [];

        for(let i=0; i<data.x.length; i++) {
            const pred = state.a * data.x[i] * data.x[i] + state.b * data.x[i] + state.c;
            xUpdates.push([data.x[i], data.x[i]]);
            yUpdates.push([data.y[i], pred]);
            indices.push(i + 2);
        }

        Plotly.restyle('plot2d', {
            x: xUpdates,
            y: yUpdates
        }, indices);
    }

    // ==========================================
    // 3D ENGINE
    // ==========================================
    const canvas = document.getElementById('canvas3d');
    const ctx = canvas.getContext('2d');
    
    const canvasRaw = document.getElementById('canvas3dRaw');
    const ctxRaw = canvasRaw.getContext('2d');

    let gridPoints = [];
    let triangles = [];

    function getViridisColor(t) {
        const c0 = [68, 1, 84]; 
        const c1 = [59, 82, 139];
        const c2 = [33, 145, 140];
        const c3 = [94, 201, 98]; 
        const c4 = [253, 231, 37];
        
        let cStart, cEnd, localT;
        if (t < 0.25) { cStart = c0; cEnd = c1; localT = t / 0.25; }
        else if (t < 0.5) { cStart = c1; cEnd = c2; localT = (t - 0.25) / 0.25; }
        else if (t < 0.75) { cStart = c2; cEnd = c3; localT = (t - 0.5) / 0.25; }
        else { cStart = c3; cEnd = c4; localT = (t - 0.75) / 0.25; }

        const r = Math.round(cStart[0] + (cEnd[0] - cStart[0]) * localT);
        const g = Math.round(cStart[1] + (cEnd[1] - cStart[1]) * localT);
        const b = Math.round(cStart[2] + (cEnd[2] - cStart[2]) * localT);
        return `rgb(${r},${g},${b})`;
    }

    function generateGrid() {
        const steps = 25; 
        
        // We iterate over A (quadratic) and B (linear). C is fixed.
        const aMin = rangeConfig.a.min, aMax = rangeConfig.a.max;
        const bMin = rangeConfig.b.min, bMax = rangeConfig.b.max;
        
        // Visualization scaling for Raw view
        const scaleA = 2.0; // Scale factor for A axis
        const scaleB = 0.5; // Scale factor for B axis
        
        gridPoints = [];
        
        for (let r = 0; r <= steps; r++) {
            const bVal = bMin + (bMax - bMin) * (r / steps);
            for (let c = 0; c <= steps; c++) {
                const aVal = aMin + (aMax - aMin) * (c / steps);
                
                // Calculate SSE using the GRID a/b but CURRENT slider c
                const val = calculateSSE(aVal, bVal, state.c, data.x, data.y);
                gridPoints.push({ a: aVal, b: bVal, val, r, c });
            }
        }

        let maxVal = 0, minVal = Infinity;
        gridPoints.forEach(p => {
            if (p.val > maxVal) maxVal = p.val;
            if (p.val < minVal) minVal = p.val;
        });

        // Compute Coordinates
        gridPoints.forEach(p => {
            // NORMALIZED COORDS (Unit Cube)
            // x -> a, z -> b
            p.wx = (p.a - aMin) / (aMax - aMin) * 2 - 1; 
            p.wz = (p.b - bMin) / (bMax - bMin) * 2 - 1; 
            
            let norm = (p.val - minVal) / (Math.max(1, maxVal - minVal)); 
            p.wy = norm * 1.5 - 0.75; 
            p.colorT = norm;

            // RAW COORDS
            const midA = (aMax + aMin) / 2;
            const midB = (bMax + bMin) / 2;
            
            p.rx = (p.a - midA) * scaleA;      
            p.rz = (p.b - midB) * scaleB;  
            p.ry = (p.val - minVal) * 0.002 - 0.5; // Scale height
        });

        triangles = [];
        for (let r = 0; r < steps; r++) {
            for (let c = 0; c < steps; c++) {
                const i0 = r * (steps + 1) + c;
                const i1 = i0 + 1;
                const i2 = (r + 1) * (steps + 1) + c;
                const i3 = i2 + 1;
                triangles.push([i0, i1, i2]);
                triangles.push([i1, i3, i2]);
            }
        }
    }

    function project(x, y, z, w, h, rotX, rotY, zoom) {
        // Rotate Y
        let px = x * Math.cos(rotY) - z * Math.sin(rotY);
        let pz = x * Math.sin(rotY) + z * Math.cos(rotY);
        let py = y;

        // Rotate X
        let py2 = py * Math.cos(rotX) - pz * Math.sin(rotX);
        let pz2 = py * Math.sin(rotX) + pz * Math.cos(rotX);

        // Perspective
        const dist = 4.5; 
        const scale = Math.min(w, h) * 0.9 * zoom;
        const f = scale / (pz2 + dist);

        return {
            x: w/2 + px * f,
            y: h/2 - py2 * f, 
            z: pz2, 
            f: f
        };
    }

    function renderScene(context, canvasWidth, canvasHeight, isRaw) {
        context.clearRect(0, 0, canvasWidth, canvasHeight);

        const currentZoom = isRaw ? canvasState.zoom * 0.1 : canvasState.zoom;

        // 1. Project Points
        const projPoints = gridPoints.map(p => {
            const X = isRaw ? p.rx : p.wx;
            const Y = isRaw ? p.ry : p.wy;
            const Z = isRaw ? p.rz : p.wz;
            
            const proj = project(X, Y, Z, canvasWidth, canvasHeight, canvasState.rotation.x, canvasState.rotation.y, currentZoom);
            return { ...p, px: proj.x, py: proj.y, pz: proj.z };
        });

        // 2. Sort Triangles
        const renderList = triangles.map(tri => {
            const p0 = projPoints[tri[0]];
            const p1 = projPoints[tri[1]];
            const p2 = projPoints[tri[2]];
            const z = (p0.pz + p1.pz + p2.pz) / 3;
            const t = (p0.colorT + p1.colorT + p2.colorT) / 3;
            return { p0, p1, p2, z, t };
        }).sort((a, b) => b.z - a.z);

        // 3. Draw Surface
        renderList.forEach(tri => {
            context.beginPath();
            context.moveTo(tri.p0.px, tri.p0.py);
            context.lineTo(tri.p1.px, tri.p1.py);
            context.lineTo(tri.p2.px, tri.p2.py);
            context.closePath();
            context.fillStyle = getViridisColor(tri.t);
            context.fill();
            context.strokeStyle = "rgba(255,255,255,0.1)";
            context.lineWidth = 1;
            context.stroke();
        });

        // 4. Draw Markers
        const aMin = rangeConfig.a.min, aMax = rangeConfig.a.max;
        const bMin = rangeConfig.b.min, bMax = rangeConfig.b.max;
        const midA = (aMax + aMin) / 2;
        const midB = (bMax + bMin) / 2;
        const scaleA = 2.0;
        const scaleB = 0.5;

        // Global Grid Min/Max for correct height normalization
        let gridMax = -Infinity, gridMin = Infinity;
        gridPoints.forEach(p => { if(p.val>gridMax) gridMax=p.val; if(p.val<gridMin) gridMin=p.val; });

        // --- Current Marker (A, B) ---
        let curX, curY, curZ;
        const curSSE = state.sse; // Calculated with current C
        // Note: The surface is generated with current C, so this marker should lie ON the surface if A,B matches a grid point.
        
        // Clamp height for display safety
        const curNorm = (curSSE - gridMin) / (Math.max(1, gridMax - gridMin));

        if (isRaw) {
            curX = (state.a - midA) * scaleA;
            curZ = (state.b - midB) * scaleB;
            curY = (curSSE - gridMin) * 0.002 - 0.5;
        } else {
            curX = (state.a - aMin) / (aMax - aMin) * 2 - 1;
            curZ = (state.b - bMin) / (bMax - bMin) * 2 - 1;
            curY = curNorm * 1.5 - 0.75;
        }
        
        // Only draw if within bounds approximately
        if(state.a >= aMin && state.a <= aMax && state.b >= bMin && state.b <= bMax) {
            const curProj = project(curX, curY, curZ, canvasWidth, canvasHeight, canvasState.rotation.x, canvasState.rotation.y, currentZoom);
            context.beginPath();
            context.arc(curProj.x, curProj.y, 6, 0, Math.PI * 2);
            context.fillStyle = "#e74c3c"; 
            context.fill();
            context.strokeStyle = "white"; 
            context.lineWidth = 2; context.stroke();
        }

        // --- Optimal Marker ---
        // This is tricky because the global optimum (Best A, Best B, Best C) might not be on the current surface (which assumes C = state.c).
        // If we want to show where the global optimum 'A' and 'B' are, we can, but the height might be wrong relative to the surface (because surface is slice at C).
        // We will draw it anyway to show the "Target" A/B on the plane.
        
        // Calculate SSE of BestA, BestB using CURRENT C to place it on the visual surface?
        // Or show true MinSSE (which might be below the surface)?
        // Let's show it projected onto the current surface for visual clarity (BestA, BestB, SSE(BestA, BestB, CurrentC)).
        // This helps the user see "I need to move my red dot to the blue dot".
        
        const optValOnSurface = calculateSSE(state.bestA, state.bestB, state.c, data.x, data.y);
        const optNorm = (optValOnSurface - gridMin) / (Math.max(1, gridMax - gridMin));

        let optX, optY, optZ;
        if (isRaw) {
            optX = (state.bestA - midA) * scaleA;
            optZ = (state.bestB - midB) * scaleB;
            optY = (optValOnSurface - gridMin) * 0.002 - 0.5;
        } else {
            optX = (state.bestA - aMin) / (aMax - aMin) * 2 - 1;
            optZ = (state.bestB - bMin) / (bMax - bMin) * 2 - 1;
            optY = optNorm * 1.5 - 0.75;
        }

        if(state.bestA >= aMin && state.bestA <= aMax && state.bestB >= bMin && state.bestB <= bMax) {
            const optProj = project(optX, optY, optZ, canvasWidth, canvasHeight, canvasState.rotation.x, canvasState.rotation.y, currentZoom);
            context.beginPath();
            context.moveTo(optProj.x, optProj.y - 6);
            context.lineTo(optProj.x + 6, optProj.y);
            context.lineTo(optProj.x, optProj.y + 6);
            context.lineTo(optProj.x - 6, optProj.y);
            context.closePath();
            context.fillStyle = "#3498db";
            context.fill();
            context.strokeStyle = "white"; 
            context.lineWidth = 2; context.stroke();
        }
    }

    function drawLoop() {
        if (canvasState.autoRotate) {
            canvasState.rotation.y += 0.005;
        }

        renderScene(ctx, canvas.width, canvas.height, false);
        renderScene(ctxRaw, canvasRaw.width, canvasRaw.height, true);
        requestAnimationFrame(drawLoop);
    }

    function resizeCanvas() {
        const c1 = document.getElementById('container3d');
        canvas.width = c1.clientWidth;
        canvas.height = c1.clientHeight;

        const c2 = document.getElementById('container3dRaw');
        canvasRaw.width = c2.clientWidth;
        canvasRaw.height = c2.clientHeight;

        generateGrid(); 
    }

    // ==========================================
    // INITIALIZATION
    // ==========================================
    window.onload = function() {
        findOptimum();
        
        // Start with something slightly off-optimal to encourage interaction
        state.a = 0.1; 
        state.b = 0.5; 
        state.c = 5.0;

        init2D();
        updateState();
        
        resizeCanvas();
        requestAnimationFrame(drawLoop);

        window.addEventListener('resize', () => {
            Plotly.Plots.resize('plot2d');
            resizeCanvas();
        });

        // Sliders
        document.getElementById('aSlider').addEventListener('input', e => {
            state.a = parseFloat(e.target.value);
            updateState();
        });
        document.getElementById('bSlider').addEventListener('input', e => {
            state.b = parseFloat(e.target.value);
            updateState();
        });
        document.getElementById('cSlider').addEventListener('input', e => {
            state.c = parseFloat(e.target.value);
            updateState();
        });

        // Buttons
        document.getElementById('optimizeBtn').addEventListener('click', () => {
            state.a = state.bestA;
            state.b = state.bestB;
            state.c = state.bestC;
            updateState(true);
        });
        document.getElementById('resetBtn').addEventListener('click', () => {
            state.a = 0.1; state.b = 0.5; state.c = 5.0;
            data.x = [...originalData.x]; data.y = [...originalData.y];
            findOptimum(); generateGrid(); updateState(true);
        });

        // Universal Controls (Apply to both canvases via Shared State)
        function setupControls(container) {
            container.addEventListener('mousedown', e => {
                canvasState.dragging = true;
                canvasState.lastMouse = { x: e.clientX, y: e.clientY };
                canvasState.autoRotate = false;
                document.getElementById('rotateBtn').classList.remove('active');
            });
            
            container.addEventListener('wheel', e => {
                e.preventDefault();
                const zoomSpeed = 0.02;
                canvasState.zoom += -e.deltaY * zoomSpeed;
                canvasState.zoom = Math.max(0.5, Math.min(8.0, canvasState.zoom));
            }, { passive: false });
        }

        setupControls(document.getElementById('container3d'));
        setupControls(document.getElementById('container3dRaw'));
        
        window.addEventListener('mouseup', () => { canvasState.dragging = false; });
        
        window.addEventListener('mousemove', e => {
            if (!canvasState.dragging) return;
            const dx = e.clientX - canvasState.lastMouse.x;
            const dy = e.clientY - canvasState.lastMouse.y;
            canvasState.rotation.y += dx * 0.01;
            canvasState.rotation.x += dy * 0.01;
            canvasState.rotation.x = Math.max(-1.5, Math.min(1.5, canvasState.rotation.x));
            canvasState.lastMouse = { x: e.clientX, y: e.clientY };
        });

        document.getElementById('rotateBtn').addEventListener('click', function() {
            canvasState.autoRotate = !canvasState.autoRotate;
            this.classList.toggle('active', canvasState.autoRotate);
            document.getElementById('rotateBtnRaw').classList.toggle('active', canvasState.autoRotate);
        });
        document.getElementById('rotateBtnRaw').addEventListener('click', function() {
            canvasState.autoRotate = !canvasState.autoRotate;
            this.classList.toggle('active', canvasState.autoRotate);
            document.getElementById('rotateBtn').classList.toggle('active', canvasState.autoRotate);
        });
        document.getElementById('rotateBtn').classList.add('active');
        document.getElementById('rotateBtnRaw').classList.add('active');

        document.getElementById('resetViewBtn').addEventListener('click', () => {
            canvasState.rotation = { x: 0.6, y: 0.4 };
            canvasState.zoom = 1.0;
        });
        document.getElementById('resetViewBtnRaw').addEventListener('click', () => {
            canvasState.rotation = { x: 0.6, y: 0.4 };
            canvasState.zoom = 1.0;
        });
    };
</script>
</body>
</html>