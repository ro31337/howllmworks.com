<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Descent Visualization</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --text-color: #212529;
            --accent-color: #3b82f6; /* Modern Blue */
            --accent-hover: #2563eb;
            --secondary-text: #6c757d;
            --border-radius: 16px;
            --shadow: 0 10px 30px -10px rgba(0,0,0,0.1);
            --font-main: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        header {
            padding: 20px 40px;
            background: var(--card-bg);
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-content h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .header-content p {
            margin: 5px 0 0 0;
            color: var(--secondary-text);
            font-size: 0.9rem;
        }

        /* Main Layout */
        .main-container {
            flex: 1;
            display: grid;
            grid-template-rows: auto 1fr;
            padding: 20px;
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
            box-sizing: border-box;
        }

        /* Controls Section */
        .controls-card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary { background: var(--accent-color); color: white; }
        .btn-primary:hover { background: var(--accent-hover); transform: translateY(-1px); }
        .btn-secondary { background: #e9ecef; color: var(--text-color); }
        .btn-secondary:hover { background: #dee2e6; }
        
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 200px;
        }
        
        .slider-group label {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--secondary-text);
            display: flex;
            justify-content: space-between;
        }

        input[type="range"] {
            width: 100%;
            accent-color: var(--accent-color);
        }

        .math-display {
            margin-left: auto;
            font-size: 0.9rem;
            background: #f8f9fa;
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid #eee;
        }

        .equation-display {
            margin-left: auto;
            font-family: monospace;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--accent-color);
            background: #f0f9ff;
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid #bae6fd;
            min-width: 200px;
            text-align: center;
        }

        /* Visualization Grid */
        .viz-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 100%;
            min-height: 0; /* Important for overflow */
        }

        .viz-card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(0,0,0,0.05);
        }

        .viz-header {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
        }

        .viz-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-color);
            margin-bottom: 4px;
            background: rgba(255,255,255,0.9);
            padding: 4px 10px;
            border-radius: 6px;
            display: inline-block;
            backdrop-filter: blur(4px);
        }

        .viz-content {
            flex: 1;
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* 3D Canvas */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: move;
        }

        /* Overlay Info */
        .overlay-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            font-family: monospace;
            font-size: 0.85rem;
            pointer-events: none;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0,0,0,0.05);
            min-width: 180px;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        .info-row:last-child { margin-bottom: 0; }
        .info-label { color: var(--secondary-text); }
        .info-value { font-weight: 700; color: var(--text-color); }

        @media (max-width: 900px) {
            .viz-grid { grid-template-columns: 1fr; grid-template-rows: 1fr 1fr; }
            .controls-card { flex-direction: column; align-items: stretch; }
            .math-display { margin-left: 0; margin-top: 10px; }
        }
    </style>
</head>
<body>

<header>
    <div class="header-content">
        <h1>Linear Regression: Gradient Descent</h1>
        <p>Visualizing the optimization process on the SSE Loss Surface</p>
    </div>
</header>

<div class="main-container">
    <!-- Controls -->
    <div class="controls-card">
        <div class="control-group">
            <button class="btn btn-primary" id="startBtn">
                <span id="playIcon">▶</span> Start Descent
            </button>
            <button class="btn btn-secondary" id="resetBtn">
                ⟲ Reset
            </button>
        </div>

        <div class="slider-group">
            <label>Learning Rate (α): <span id="lrValue">0.05</span></label>
            <input type="range" id="lrSlider" min="0.01" max="0.2" step="0.01" value="0.05">
        </div>

        <div class="equation-display" id="equationDisplay">
            y = 0.00x + 0.00
        </div>
    </div>

    <!-- Visualizations -->
    <div class="viz-grid">
        <!-- 2D Data Plot -->
        <div class="viz-card">
            <div class="viz-header">
                <div class="viz-title">Model Space (2D)</div>
            </div>
            <div id="plot2d" class="viz-content"></div>
            <div class="overlay-info">
                <div class="info-row"><span class="info-label">Epoch</span><span class="info-value" id="epochDisplay">0</span></div>
                <div class="info-row"><span class="info-label">Slope (a)</span><span class="info-value" id="slopeDisplay">0.00</span></div>
                <div class="info-row"><span class="info-label">Intercept (b)</span><span class="info-value" id="interceptDisplay">0.00</span></div>
            </div>
        </div>

        <!-- 3D Loss Surface -->
        <div class="viz-card">
            <div class="viz-header">
                <div class="viz-title">Loss Landscape (SSE)</div>
            </div>
            <div class="viz-content" id="canvasContainer">
                <canvas id="canvas3d"></canvas>
            </div>
            <div class="overlay-info">
                <div class="info-row"><span class="info-label">Current Loss</span><span class="info-value" id="lossDisplay">0.00</span></div>
                <div class="info-row"><span class="info-label">Gradient Norm</span><span class="info-value" id="gradDisplay">0.00</span></div>
            </div>
        </div>
    </div>
</div>

<script>
    // ==========================================
    // CONFIGURATION & STATE
    // ==========================================
    const config = {
        bgColor: '#ffffff',
        gridColor: 'rgba(0,0,0,0.1)',
        surfaceOpacity: 0.9,
        colors: {
            low: [59, 82, 139],    // Deep Blue
            mid: [33, 145, 140],   // Teal
            high: [253, 231, 37],  // Yellow
            path: '#ffffff',       // Path color
            point: '#ef4444'       // Current point red
        },
        // Animation Physics
        lerpFactor: 0.1, // "Smoothing" factor (lower = smoother/slower)
        stepThreshold: 0.001 // How close to target before taking next step
    };

    const data = {
        x: [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5],
        y: [2, 3.2, 3.8, 5.1, 6.2, 6.8, 8.1, 8.9, 10.2, 11]
    };

    const M = data.x.length;

    let state = {
        // Target (Mathematical) State
        targetM: 0,
        targetB: 0,
        
        // Visual (Rendered) State
        visualM: 0,
        visualB: 0,
        
        lr: 0.01,       // Learning Rate (Lowered for visibility)
        history: [],    // Optimization path (only completed steps)
        
        isRunning: false,
        epoch: 0,
        isConverged: false
    };

    let camera = {
        rotX: 0.8,
        rotY: 0.5,
        zoom: 1.1,
        autoRotate: true,
        lastMouse: { x: 0, y: 0 },
        isDragging: false
    };

    // Precomputed Grid for 3D Surface
    let gridGeometry = {
        points: [],
        triangles: [],
        minVal: Infinity,
        maxVal: -Infinity
    };

    // Range for the visualization grid
    const range = {
        m: { min: -1, max: 4 },
        b: { min: -2, max: 4 }
    };

    // ==========================================
    // MATH & OPTIMIZATION
    // ==========================================
    function calculateSSE(m, b) {
        let error = 0;
        for (let i = 0; i < M; i++) {
            const pred = m * data.x[i] + b;
            error += (data.y[i] - pred) ** 2;
        }
        return error;
    }

    function calculateGradient(m, b) {
        let dm = 0;
        let db = 0;
        for (let i = 0; i < M; i++) {
            const pred = m * data.x[i] + b;
            const diff = pred - data.y[i];
            dm += diff * data.x[i];
            db += diff;
        }
        return { dm: (2/M) * dm, db: (2/M) * db }; 
    }

    function planNextStep() {
        if (state.isConverged) return;

        const grads = calculateGradient(state.targetM, state.targetB);
        const gradNorm = Math.sqrt(grads.dm**2 + grads.db**2);

        if (gradNorm < 0.01) {
            state.isConverged = true;
            toggleSimulation(); // Stop
            return;
        }

        // Record history of the START of the step (where we are now)
        state.history.push({ 
            m: state.targetM, 
            b: state.targetB, 
            loss: calculateSSE(state.targetM, state.targetB) 
        });

        // Update Target
        state.targetM = state.targetM - state.lr * grads.dm;
        state.targetB = state.targetB - state.lr * grads.db;
        state.epoch++;
    }

    // ==========================================
    // 3D ENGINE
    // ==========================================
    const canvas = document.getElementById('canvas3d');
    const ctx = canvas.getContext('2d');

    function initGrid() {
        const steps = 40;
        const pts = [];
        
        for (let r = 0; r <= steps; r++) {
            const b = range.b.min + (r / steps) * (range.b.max - range.b.min);
            for (let c = 0; c <= steps; c++) {
                const m = range.m.min + (c / steps) * (range.m.max - range.m.min);
                const val = calculateSSE(m, b);
                pts.push({ m, b, val, r, c });
                if (val < gridGeometry.minVal) gridGeometry.minVal = val;
                if (val > gridGeometry.maxVal) gridGeometry.maxVal = val;
            }
        }

        pts.forEach(p => {
            p.nx = (p.m - range.m.min) / (range.m.max - range.m.min) * 2 - 1;
            p.nz = (p.b - range.b.min) / (range.b.max - range.b.min) * 2 - 1;
            p.ny = ((p.val - gridGeometry.minVal) / (gridGeometry.maxVal - gridGeometry.minVal)) * 1.5 - 0.5;
            p.t = (p.val - gridGeometry.minVal) / (gridGeometry.maxVal - gridGeometry.minVal);
        });

        const tris = [];
        for (let r = 0; r < steps; r++) {
            for (let c = 0; c < steps; c++) {
                const i0 = r * (steps + 1) + c;
                const i1 = i0 + 1;
                const i2 = (r + 1) * (steps + 1) + c;
                const i3 = i2 + 1;
                tris.push([i0, i1, i2]);
                tris.push([i1, i3, i2]);
            }
        }

        gridGeometry.points = pts;
        gridGeometry.triangles = tris;
    }

    function project(x, y, z, width, height) {
        const rx = x * Math.cos(camera.rotY) - z * Math.sin(camera.rotY);
        const rz = x * Math.sin(camera.rotY) + z * Math.cos(camera.rotY);
        const ry = y * Math.cos(camera.rotX) - rz * Math.sin(camera.rotX);
        const rz2 = y * Math.sin(camera.rotX) + rz * Math.cos(camera.rotX);
        const dist = 4.0;
        const scale = Math.min(width, height) * 0.7 * camera.zoom;
        const f = scale / (rz2 + dist);
        return { x: width/2 + rx * f, y: height/2 - ry * f, z: rz2 };
    }

    function getColor(t) {
        t = Math.max(0, Math.min(1, t));
        let cStart, cEnd, localT;
        if (t < 0.5) {
            cStart = config.colors.low;
            cEnd = config.colors.mid;
            localT = t * 2;
        } else {
            cStart = config.colors.mid;
            cEnd = config.colors.high;
            localT = (t - 0.5) * 2;
        }
        const r = Math.round(cStart[0] + (cEnd[0] - cStart[0]) * localT);
        const g = Math.round(cStart[1] + (cEnd[1] - cStart[1]) * localT);
        const b = Math.round(cStart[2] + (cEnd[2] - cStart[2]) * localT);
        return `rgb(${r},${g},${b})`;
    }

    function render3D() {
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        // 1. Grid
        const projPoints = gridGeometry.points.map(p => {
            const proj = project(p.nx, p.ny, p.nz, width, height);
            return { ...p, px: proj.x, py: proj.y, pz: proj.z };
        });

        const renderList = gridGeometry.triangles.map(tri => {
            const p0 = projPoints[tri[0]];
            const p1 = projPoints[tri[1]];
            const p2 = projPoints[tri[2]];
            return { p0, p1, p2, z: (p0.pz + p1.pz + p2.pz) / 3, t: (p0.t + p1.t + p2.t) / 3 };
        }).sort((a, b) => b.z - a.z);

        renderList.forEach(tri => {
            ctx.beginPath();
            ctx.moveTo(tri.p0.px, tri.p0.py);
            ctx.lineTo(tri.p1.px, tri.p1.py);
            ctx.lineTo(tri.p2.px, tri.p2.py);
            ctx.closePath();
            ctx.fillStyle = getColor(tri.t);
            ctx.fill();
            ctx.strokeStyle = "rgba(255,255,255,0.08)";
            ctx.lineWidth = 0.5;
            ctx.stroke();
        });

        // 2. Completed Path (Static)
        if (state.history.length > 0) {
            ctx.beginPath();
            const pathPoints = state.history.map(h => {
                const nx = (h.m - range.m.min) / (range.m.max - range.m.min) * 2 - 1;
                const nz = (h.b - range.b.min) / (range.b.max - range.b.min) * 2 - 1;
                const ny = ((h.loss - gridGeometry.minVal) / (gridGeometry.maxVal - gridGeometry.minVal)) * 1.5 - 0.5;
                return project(nx, ny, nz, width, height);
            });

            if (pathPoints.length > 1) {
                ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
                for (let i = 1; i < pathPoints.length; i++) {
                    ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
                }
            }
            // Draw line to current Visual Head
            if (pathPoints.length > 0) {
                const last = pathPoints[pathPoints.length - 1];
                ctx.lineTo(last.x, last.y); 
                // We'll draw the connection to visual head separately
            }
            
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // 3. Current Visual Head (Interpolating)
        // Project Visual State
        const vm = state.visualM;
        const vb = state.visualB;
        const vLoss = calculateSSE(vm, vb); // Calculate loss for visual point for correct height
        
        const vnx = (vm - range.m.min) / (range.m.max - range.m.min) * 2 - 1;
        const vnz = (vb - range.b.min) / (range.b.max - range.b.min) * 2 - 1;
        const vny = ((vLoss - gridGeometry.minVal) / (gridGeometry.maxVal - gridGeometry.minVal)) * 1.5 - 0.5;
        
        const head = project(vnx, vny, vnz, width, height);

        // Draw line from last history point to visual head
        if (state.history.length > 0) {
             const lastH = state.history[state.history.length - 1];
             const lastNx = (lastH.m - range.m.min) / (range.m.max - range.m.min) * 2 - 1;
             const lastNz = (lastH.b - range.b.min) / (range.b.max - range.b.min) * 2 - 1;
             const lastNy = ((lastH.loss - gridGeometry.minVal) / (gridGeometry.maxVal - gridGeometry.minVal)) * 1.5 - 0.5;
             const lastProj = project(lastNx, lastNy, lastNz, width, height);
             
             ctx.beginPath();
             ctx.moveTo(lastProj.x, lastProj.y);
             ctx.lineTo(head.x, head.y);
             ctx.strokeStyle = "white";
             ctx.lineWidth = 2;
             ctx.stroke();
        }

        // Draw Shadow
        ctx.beginPath();
        ctx.arc(head.x, head.y + 10, 4, 0, Math.PI*2);
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.fill();

        // Draw Ball
        ctx.beginPath();
        ctx.arc(head.x, head.y, 6, 0, Math.PI*2);
        ctx.fillStyle = "#ef4444";
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    function animate() {
        // Rotation
        if (camera.autoRotate && !camera.isDragging && !state.isRunning) {
            camera.rotY += 0.0005;
        }

        // Smooth Interpolation Logic
        if (state.isRunning && !state.isConverged) {
            const dm = state.targetM - state.visualM;
            const db = state.targetB - state.visualB;
            const dist = Math.sqrt(dm*dm + db*db);

            if (dist < config.stepThreshold) {
                // Snap to target and plan next step
                state.visualM = state.targetM;
                state.visualB = state.targetB;
                planNextStep();
                updateUIValues(); // Update numbers only on step completion
            } else {
                // Move visually towards target
                state.visualM += dm * config.lerpFactor;
                state.visualB += db * config.lerpFactor;
                update2DLine(); // Smoothly move 2D line
            }
        }

        render3D();
        requestAnimationFrame(animate);
    }

    // ==========================================
    // 2D PLOTLY
    // ==========================================
    function init2D() {
        const layout = {
            margin: { t: 20, r: 20, b: 40, l: 40 },
            xaxis: { title: 'Input (x)', range: [0, 6], fixedrange: true, gridcolor: '#f0f0f0' },
            yaxis: { title: 'Output (y)', range: [0, 15], fixedrange: true, gridcolor: '#f0f0f0' },
            showlegend: false,
            plot_bgcolor: 'white',
            paper_bgcolor: 'white',
            height: document.getElementById('plot2d').clientHeight
        };

        const traceData = {
            x: data.x,
            y: data.y,
            mode: 'markers',
            marker: { color: config.colors.mid[1], size: 10, color: 'rgb(59, 130, 246)' },
            type: 'scatter'
        };

        const traceLine = {
            x: [0, 6],
            y: [state.visualB, state.visualM * 6 + state.visualB],
            mode: 'lines',
            line: { color: '#ef4444', width: 3 },
            type: 'scatter'
        };

        Plotly.newPlot('plot2d', [traceData, traceLine], layout, { responsive: true, displayModeBar: false });
    }

    function update2DLine() {
        // Updates based on VISUAL state (smooth)
        Plotly.restyle('plot2d', {
            y: [[state.visualB, state.visualM * 6 + state.visualB]]
        }, [1]);
    }
    
    function updateUIValues() {
        const loss = calculateSSE(state.targetM, state.targetB);
        const grads = calculateGradient(state.targetM, state.targetB);
        const gradNorm = Math.sqrt(grads.dm**2 + grads.db**2);
        
        document.getElementById('epochDisplay').textContent = state.epoch;
        document.getElementById('slopeDisplay').textContent = state.targetM.toFixed(3);
        document.getElementById('interceptDisplay').textContent = state.targetB.toFixed(3);
        document.getElementById('lossDisplay').textContent = loss.toFixed(2);
        document.getElementById('gradDisplay').textContent = gradNorm.toFixed(3);

        const sign = state.targetB >= 0 ? '+' : '-';
        document.getElementById('equationDisplay').textContent = `y = ${state.targetM.toFixed(2)}x ${sign} ${Math.abs(state.targetB).toFixed(2)}`;
    }

    // ==========================================
    // SETUP & EVENTS
    // ==========================================
    function toggleSimulation() {
        state.isRunning = !state.isRunning;
        const btn = document.getElementById('startBtn');
        
        if (state.isRunning) {
            btn.innerHTML = `<span id="playIcon">⏸</span> Pause Descent`;
            btn.classList.add('active');
            camera.autoRotate = false;
            
            // If first start, plan first step immediately
            if (state.epoch === 0 && state.history.length === 0) {
                 planNextStep();
            }
        } else {
            btn.innerHTML = `<span id="playIcon">▶</span> Resume Descent`;
            btn.classList.remove('active');
        }
    }

    function resetSimulation() {
        state.isRunning = false;
        state.isConverged = false;
        
        // Reset everything
        state.targetM = 0;
        state.targetB = 0;
        state.visualM = 0;
        state.visualB = 0;
        state.history = [];
        state.epoch = 0;
        
        const loss = calculateSSE(0, 0);
        document.getElementById('startBtn').innerHTML = `<span id="playIcon">▶</span> Start Descent`;
        document.getElementById('epochDisplay').textContent = "0";
        document.getElementById('lossDisplay').textContent = loss.toFixed(2);
        document.getElementById('slopeDisplay').textContent = "0.00";
        document.getElementById('interceptDisplay').textContent = "0.00";
        document.getElementById('gradDisplay').textContent = "0.00";
        document.getElementById('equationDisplay').textContent = "y = 0.00x + 0.00";
        
        update2DLine();
    }

    window.onload = function() {
        initGrid();
        
        const container = document.getElementById('canvasContainer');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        
        init2D();
        resetSimulation();
        animate();

        window.addEventListener('resize', () => {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            Plotly.Plots.resize('plot2d');
        });

        document.getElementById('startBtn').addEventListener('click', toggleSimulation);
        document.getElementById('resetBtn').addEventListener('click', resetSimulation);
        
        document.getElementById('lrSlider').addEventListener('input', (e) => {
            state.lr = parseFloat(e.target.value);
            document.getElementById('lrValue').textContent = state.lr;
        });

        // 3D Interactions
        canvas.addEventListener('mousedown', e => {
            camera.isDragging = true;
            camera.lastMouse = { x: e.clientX, y: e.clientY };
            camera.autoRotate = false;
        });
        
        window.addEventListener('mouseup', () => { 
            camera.isDragging = false;
            camera.autoRotate = true;
        });
        
        window.addEventListener('mousemove', e => {
            if (!camera.isDragging) return;
            const dx = e.clientX - camera.lastMouse.x;
            const dy = e.clientY - camera.lastMouse.y;
            camera.rotY += dx * 0.01;
            camera.rotX += dy * 0.01;
            camera.rotX = Math.max(-1.5, Math.min(1.5, camera.rotX));
            camera.lastMouse = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            camera.zoom -= e.deltaY * 0.001;
            camera.zoom = Math.max(0.5, Math.min(3.0, camera.zoom));
        }, { passive: false });
    };
</script>
</body>
</html>