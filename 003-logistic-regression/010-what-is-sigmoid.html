<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ß—Ç–æ —Ç–∞–∫–æ–µ –°–∏–≥–º–æ–∏–¥–∞? - –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --accent-color: #f5576c;
            --text-color: #2c3e50;
            --bg-color: #f8f9fa;
        }

        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: var(--text-color);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        h1, h2, h3 { color: var(--text-color); }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            background: linear-gradient(120deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 40px;
            font-size: 1.2em;
        }

        /* Tabs */
        .tabs {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 30px;
            background: #f1f3f5;
            padding: 10px;
            border-radius: 15px;
        }

        .tab-btn {
            padding: 12px 24px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            color: #666;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .tab-btn:hover {
            background: rgba(255,255,255,0.5);
            color: var(--primary-color);
        }

        .tab-btn.active {
            background: white;
            color: var(--primary-color);
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }

        /* Sections */
        .section {
            margin-bottom: 40px;
        }

        .formula-box {
            background: white;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
            text-align: center;
            font-size: 1.4em;
            margin: 20px 0;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.02);
        }

        .info-box {
            background: #e3f2fd;
            border-left: 5px solid #2196f3;
            padding: 20px;
            border-radius: 0 10px 10px 0;
            margin: 20px 0;
        }

        /* Grid Layout */
        .grid-2 {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 30px;
            margin-top: 30px;
        }

        @media (max-width: 900px) {
            .grid-2 { grid-template-columns: 1fr; }
        }

        /* Controls */
        .controls {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            border: 1px solid #e9ecef;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 0.95em;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #dfe6e9;
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .value-badge {
            background: var(--primary-color);
            color: white;
            padding: 2px 8px;
            border-radius: 6px;
            font-size: 0.85em;
            font-family: monospace;
        }

        /* Plot */
        .plot-container {
            height: 500px;
            border-radius: 15px;
            overflow: hidden;
            background: white;
            border: 1px solid #e9ecef;
        }

        /* Explanation Section */
        .sigmoid-explanation {
            margin-top: 50px;
            padding-top: 30px;
            border-top: 2px dashed #e9ecef;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>–ß—Ç–æ —Ç–∞–∫–æ–µ –°–∏–≥–º–æ–∏–¥–∞?</h1>
    <p class="subtitle">–ü–æ–Ω–∏–º–∞–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ —Ä–∞–∑–Ω—ã–µ –Ω–æ—Ç–∞—Ü–∏–∏</p>

    <!-- Navigation Tabs -->
    <div class="tabs">
        <button class="tab-btn active" onclick="setMode('school')">–®–∫–æ–ª–∞ / –ò–Ω—Ç—É–∏—Ü–∏—è</button>
        <button class="tab-btn" onclick="setMode('stats')">–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</button>
        <button class="tab-btn" onclick="setMode('ml')">ML / –ù–µ–π—Ä–æ—Å–µ—Ç–∏</button>
        <button class="tab-btn" onclick="setMode('linalg')">–õ–∏–Ω–µ–π–Ω–∞—è –∞–ª–≥–µ–±—Ä–∞</button>
    </div>

    <!-- Active Formula Display -->
    <div class="section">
        <div id="formula-container" class="formula-box"></div>
        <div id="description-container" class="info-box"></div>
    </div>

    <!-- Interactive Area -->
    <div class="grid-2">
        <!-- Controls Side -->
        <div class="controls">
            <h3>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã</h3>
            <p style="font-size: 0.9em; color: #666; margin-bottom: 20px;">
                –ò–∑–º–µ–Ω—è–π—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–∏–∂–µ, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å, –∫–∞–∫ –º–µ–Ω—è–µ—Ç—Å—è —Ñ–æ—Ä–º–∞ —Å–∏–≥–º–æ–∏–¥—ã.
            </p>
            <div id="sliders-container">
                <!-- Sliders injected by JS -->
            </div>
        </div>

        <!-- Visualization Side -->
        <div class="plot-container" id="sigmoidPlot"></div>
    </div>

    <!-- Core Concept Explanation -->
    <div class="section sigmoid-explanation">
        <h2>üåÄ –ï–¥–∏–Ω–∞—è —Å—É—Ç—å: –°–∏–≥–º–æ–∏–¥–∞</h2>
        <p>–ù–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º—É–ª—ã –∑–∞–ø–∏—Å–∏ \(z\), –≤—Å–µ –æ–Ω–∏ –≤ –∏—Ç–æ–≥–µ –ø—Ä–æ—Ö–æ–¥—è—Ç —á–µ—Ä–µ–∑ –æ–¥–Ω—É –∏ —Ç—É –∂–µ —Ñ—É–Ω–∫—Ü–∏—é ‚Äî <strong>–°–∏–≥–º–æ–∏–¥—É</strong>.</p>
        
        <div class="formula-box">
            $$ \sigma(z) = \frac{1}{1 + e^{-z}} $$
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 30px;">
            <div>
                <h3>–ó–∞—á–µ–º —ç—Ç–æ –Ω—É–∂–Ω–æ?</h3>
                <p>–õ–∏–Ω–µ–π–Ω–∞—è —á–∞—Å—Ç—å (\(z\)) –º–æ–∂–µ—Ç –≤—ã–¥–∞–≤–∞—Ç—å –ª—é–±—ã–µ —á–∏—Å–ª–∞: –æ—Ç \(-\infty\) –¥–æ \(+\infty\).<br>
                –ù–æ –Ω–∞–º —á–∞—Å—Ç–æ –Ω—É–∂–Ω–∞ <strong>–≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å</strong> (–æ—Ç 0 –¥–æ 1).</p>
                <p>–°–∏–≥–º–æ–∏–¥–∞ "—Å–ø–ª—é—â–∏–≤–∞–µ—Ç" –ª—é–±—É—é –ø—Ä—è–º—É—é –ª–∏–Ω–∏—é –≤ S-–æ–±—Ä–∞–∑–Ω—É—é –∫—Ä–∏–≤—É—é, –∫–æ—Ç–æ—Ä–∞—è –≤—Å–µ–≥–¥–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ (0, 1).</p>
            </div>
            <div>
                <h3>–°–≤–æ–π—Å—Ç–≤–∞</h3>
                <ul>
                    <li>–ï—Å–ª–∏ \(z = 0\), —Ç–æ \(\sigma(z) = 0.5\)</li>
                    <li>–ï—Å–ª–∏ \(z\) –æ—á–µ–Ω—å –±–æ–ª—å—à–æ–µ, \(\sigma(z) \to 1\)</li>
                    <li>–ï—Å–ª–∏ \(z\) –æ—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–æ–µ, \(\sigma(z) \to 0\)</li>
                </ul>
            </div>
        </div>
    </div>
</div>

<script>
    // --- State Management ---
    const state = {
        mode: 'school',
        w0: 0,   // Bias / Intercept
        w1: 1,   // Weight 1 / Slope
        w2: 0.5, // Weight 2 (for multi-feature demo)
        x2: 0    // Fixed input for 2nd feature
    };

    // --- Configuration for Modes ---
    const modes = {
        school: {
            label: '–®–∫–æ–ª–∞ / –ò–Ω—Ç—É–∏—Ü–∏—è',
            formula: '$$ z = \\beta_0 + \\beta_1 x $$',
            desc: '<strong>–û–¥–Ω–∞ —Ñ–∏—á–∞, –æ–¥–Ω–∞ –ø—Ä—è–º–∞—è.</strong> –°–∞–º—ã–π –ø—Ä–æ—Å—Ç–æ–π –∏ –∏–Ω—Ç—É–∏—Ç–∏–≤–Ω—ã–π –≤–∏–¥. –ú—ã —Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ \(x\) –≤–ª–∏—è–µ—Ç –Ω–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç.',
            sliders: [
                { key: 'w0', label: '\\(\beta_0\) (—Å–¥–≤–∏–≥)', min: -5, max: 5, step: 0.1 },
                { key: 'w1', label: '\\(\beta_1\) (–Ω–∞–∫–ª–æ–Ω)', min: -5, max: 5, step: 0.1 }
            ]
        },
        stats: {
            label: '–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞',
            formula: '$$ z = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\dots $$',
            desc: '<strong>–ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è.</strong> –ö–∞–∂–¥–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è (\(x_i\)) –∏–º–µ–µ—Ç —Å–≤–æ–π –≤–µ—Å (\\(\beta_i\)). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å \(x_2\), —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å, –∫–∞–∫ –≤–ª–∏—è–Ω–∏–µ –¥—Ä—É–≥–∏—Ö —Ñ–∞–∫—Ç–æ—Ä–æ–≤ —Å–¥–≤–∏–≥–∞–µ—Ç –∫—Ä–∏–≤—É—é –¥–ª—è \(x_1\).',
            sliders: [
                { key: 'w0', label: '\\(\beta_0\) (intercept)', min: -5, max: 5, step: 0.1 },
                { key: 'w1', label: '\\(\beta_1\) (–≤–µ—Å x‚ÇÅ)', min: -5, max: 5, step: 0.1 },
                { key: 'w2', label: '\\(\beta_2\) (–≤–µ—Å x‚ÇÇ)', min: -5, max: 5, step: 0.1 },
                { key: 'x2', label: '\(x_2\) (–∫–æ–Ω—Ç–µ–∫—Å—Ç)', min: -5, max: 5, step: 0.1 }
            ]
        },
        ml: {
            label: 'ML / –ù–µ–π—Ä–æ—Å–µ—Ç–∏',
            formula: '$$ z = w_1x_1 + w_2x_2 + \dots + b $$',
            desc: '<strong>–Ø–∑—ã–∫ –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π.</strong> –¢–æ –∂–µ —Å–∞–º–æ–µ, –Ω–æ –¥—Ä—É–≥–∏–µ –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏—è: \(w\) (weights) –≤–º–µ—Å—Ç–æ \(\beta\), –∏ \(b\) (bias) –≤–º–µ—Å—Ç–æ \(\beta_0\).',
            sliders: [
                { key: 'w0', label: 'b (bias)', min: -5, max: 5, step: 0.1 },
                { key: 'w1', label: 'w‚ÇÅ (weight 1)', min: -5, max: 5, step: 0.1 },
                { key: 'w2', label: 'w‚ÇÇ (weight 2)', min: -5, max: 5, step: 0.1 },
                { key: 'x2', label: 'x‚ÇÇ (–≤—Ö–æ–¥ 2)', min: -5, max: 5, step: 0.1 }
            ]
        },
        linalg: {
            label: '–õ–∏–Ω–µ–π–Ω–∞—è –∞–ª–≥–µ–±—Ä–∞',
            formula: '$$ z = \\mathbf{X}\\mathbf{w} + b $$',
            desc: '<strong>–í–µ–∫—Ç–æ—Ä–Ω–∞—è —Ñ–æ—Ä–º–∞.</strong> –°–∞–º–∞—è –∫–æ–º–ø–∞–∫—Ç–Ω–∞—è –∑–∞–ø–∏—Å—å. –£–¥–æ–±–Ω–∞ –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏–π –Ω–∞ –≤–∏–¥–µ–æ–∫–∞—Ä—Ç–∞—Ö (GPU). \(\mathbf{w}\) ‚Äî —ç—Ç–æ –≤–µ–∫—Ç–æ—Ä –≤–µ—Å–æ–≤ \([w_1, w_2]\).',
            sliders: [
                { key: 'w0', label: 'b (—Å–∫–∞–ª—è—Ä)', min: -5, max: 5, step: 0.1 },
                { key: 'w1', label: 'w[0] (–≤–µ–∫—Ç–æ—Ä)', min: -5, max: 5, step: 0.1 },
                { key: 'w2', label: 'w[1] (–≤–µ–∫—Ç–æ—Ä)', min: -5, max: 5, step: 0.1 },
                { key: 'x2', label: 'x[1] (–≤—Ö–æ–¥)', min: -5, max: 5, step: 0.1 }
            ]
        }
    };

    // --- Core Logic ---
    function setMode(modeKey) {
        state.mode = modeKey;
        
        // Update Tabs UI
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.remove('active');
            if (btn.textContent.includes(modes[modeKey].label.split(' / ')[0])) { // Simple matching
                btn.classList.add('active');
            }
        });
        // Better tab matching by index or logic if text differs, but simple contains check works for now or strict click mapping
        // Re-implementing strictly based on onclick binding:
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        const activeBtn = Array.from(document.querySelectorAll('.tab-btn')).find(b => b.getAttribute('onclick').includes(modeKey));
        if (activeBtn) activeBtn.classList.add('active');

        // Update Content
        renderFormula();
        renderSliders();
        updatePlot();
    }

    function renderFormula() {
        const config = modes[state.mode];
        document.getElementById('formula-container').innerHTML = config.formula;
        document.getElementById('description-container').innerHTML = config.desc;
        // Trigger MathJax re-render
        if (window.MathJax) {
            MathJax.typesetPromise([document.getElementById('formula-container')]);
            // Also re-render slider labels if they contain math
            setTimeout(() => MathJax.typesetPromise([document.getElementById('sliders-container')]), 50);
        }
    }

    function renderSliders() {
        const container = document.getElementById('sliders-container');
        container.innerHTML = '';
        
        modes[state.mode].sliders.forEach(sliderConfig => {
            const group = document.createElement('div');
            group.className = 'control-group';
            
            const labelRow = document.createElement('label');
            labelRow.innerHTML = `<span>${sliderConfig.label}</span> <span class="value-badge" id="val-${sliderConfig.key}">${state[sliderConfig.key]}</span>`;
            
            const input = document.createElement('input');
            input.type = 'range';
            input.min = sliderConfig.min;
            input.max = sliderConfig.max;
            input.step = sliderConfig.step;
            input.value = state[sliderConfig.key];
            
            input.oninput = (e) => {
                const val = parseFloat(e.target.value);
                state[sliderConfig.key] = val;
                document.getElementById(`val-${sliderConfig.key}`).textContent = val;
                updatePlot();
            };

            group.appendChild(labelRow);
            group.appendChild(input);
            container.appendChild(group);
        });
        
        // Render MathJax in labels
        if (window.MathJax) {
            MathJax.typesetPromise([container]);
        }
    }

    function sigmoid(z) {
        return 1 / (1 + Math.exp(-z));
    }

    function calculateZ(x1) {
        // Base: w0 + w1*x1
        let z = state.w0 + state.w1 * x1;
        
        // Add second feature effect if applicable (Stats, ML, LinAlg modes imply multi-feature potential)
        // Even if School mode only shows w0/w1 sliders, the formula logic remains consistent.
        // But School mode sliders don't include w2/x2, so they stay at default or whatever state has.
        // To be clean, for School mode we might want to ignore w2/x2, but state persistence is fine.
        
        if (state.mode !== 'school') {
            z += state.w2 * state.x2;
        }
        
        return z;
    }

    function updatePlot() {
        const xValues = [];
        const yValues = [];
        const zValues = []; // Store Z for coloring/hover maybe?

        // Generate points
        for (let x = -6; x <= 6; x += 0.1) {
            xValues.push(x);
            const z = calculateZ(x);
            yValues.push(sigmoid(z));
        }

        const trace = {
            x: xValues,
            y: yValues,
            mode: 'lines',
            line: {
                color: '#667eea',
                width: 4
            },
            fill: 'tozeroy',
            fillcolor: 'rgba(102, 126, 234, 0.1)'
        };

        const layout = {
            title: { text: '–ì—Ä–∞—Ñ–∏–∫ –°–∏–≥–º–æ–∏–¥—ã', font: { size: 18, color: '#2c3e50' } },
            xaxis: { 
                title: 'x (–∏–ª–∏ x‚ÇÅ)', 
                zeroline: true, 
                gridcolor: '#f1f3f5' 
            },
            yaxis: { 
                title: '–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å œÉ(z)', 
                range: [-0.1, 1.1], 
                gridcolor: '#f1f3f5' 
            },
            margin: { t: 40, r: 20, l: 50, b: 50 },
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: 'rgba(0,0,0,0)'
        };

        const config = { responsive: true, displayModeBar: false };

        Plotly.newPlot('sigmoidPlot', [trace], layout, config);
    }

    // --- Init ---
    // Wait for MathJax then render
    window.addEventListener('load', () => {
        setMode('school');
    });

</script>

</body>
</html>